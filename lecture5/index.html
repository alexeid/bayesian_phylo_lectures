---
lecture_num: 5
---
<section>
    <h2>Molecules as Documents of Evolutionary History</h2>
    
    <ul class="spaced" style="margin-top:5%; width:85%">
        <li>Macromolecules contain information about the processes and
history that formed them
<pre style="font-size:22px;box-shadow:none;margin-bottom:0">
HIV-1 (UK.) ATC<font color="red">G</font>GATGCTA<font color="red">A</font>AGC<font color="red">A</font>TATGA<font color="red">C</font>ACAGAGGTACA<font color="red">TAA</font>TGTTT
HIV-1 (USA) ATC<font color="red">A</font>GATGCTA<font color="red">G</font>AGC<font color="red">T</font>TATGA<font color="red">T</font>ACAGAGGTACA<font color="red">---</font>TGTTT

</pre>
</li>
        <li>However, this information is not complete, so the full history
must be inferred</li>
        <li>One of the aims of computational biology is to decipher the
information held in molecular sequences about the process
and history of evolution
        </li>
    </ul>
</section>

<section>
    <h2>Phylogenetics</h2>


    <ul class="spaced" style="margin-top:5%; width:85%">
		<li> Similarity (due to homology) is viewed as evidence of common ancestry </li>
    	<ul class="spaced">
			<li>Homology: the result of inheritance from a common ancestor</li>
		</ul>
		<li> Phylogenetic trees are used to portray relationships based upon common ancestry </li>
		<li>Monophyletic groups (clades) - contain species which are more closely related to each other than to any outside of the group </li>
		<li>Phylogenetics has in recent years become a statistical science based on probabilistic models of evolution (more on this in later lectures). </li>
	</ul>

</section>

<section>
	<h2>A typical molecular phylogenetic analysis</h2>
	
    <ol class="spaced" style="margin-top:5%; width:70%">
	<li> Collect homologous sequences </li>
	<li> Construct a multiple sequence alignment </li>
	<li> Phylogeny reconstruction </li>
	<li> Test the reliability of the estimated phylogeny  </li>
	<li> Interpretation and application of phylogenies  </li>
	</ol>
</section>

<section>
	<h2>Applications of phylogenetics</h2>
	
	
    <ul class="spaced" style="margin-top:5%; width:85%">
	<li> Inferring relationships among species and genes </li> 
	<li> Estimating divergence times </li>
	<li> Identifying functional elements in comparisons of genomic sequences </li>
	<li> Detecting molecular adaptation </li>
	<li> Forensics </li>
	<li> Studying the emergence and spread of viral pandemics </li>
	<li> many more... </li>
	</ul>
</section>

<section>
	<h2>Types of phylogenies and representations</h2>
	
	<img data-src="typesOfPhylogenies.svg" style="width:95%">
</section>

<section>
	<h2>Bifurcating (binary) and multifurcating trees</h2>
	
	<img data-src="bifurcatingAndMultifurcatingTrees.svg" style="width:85%">
	
	<ul style="margin-left:5%; width:70%">
	<li>In a rooted tree a <font color="red">polytomy</font> is a node with more than 2 children. <br>
	<li>In an unrooted tree a <font color="red">polytomy</font> is a node of degree 4 or greater.
	</ul>

</section>

<section>
	<h2>Rooted and unrooted trees</h2>

	<img data-src="rootedToUnrooted.svg" style="width:70%">
	
	<div align="left" style="margin-top:5%; margin-left:15%; width:70%">
	Most phylogeny-reconstruction methods are unable to identify the root of the tree, so unrooted trees are inferred. 
	This includes the maximum parsimony method, as well as those distance, likelihood and Bayesian methods that do not assume a molecular clock.
	</div>

</section>

<section>
	<h2>Rooting trees using an outgroup</h2>
	
	<img data-src="RootingTreesOutgroup.png" style="width:100%">

</section>

<section>
	<h2>The same unrooted tree</h2>

	<img data-src="unrootedTrees.png" style="width:100%">

</section>

<section>
	<h2>Anatomy of a tree</h2>
</section>

<section>
	<h2>How many trees are there?</h2>
</section>

<section>
	<h2>Counting unrooted trees with stepwise addition algorithm</h2>
</section>

<section>
	<h2>The topological distance between two trees</h2>
</section>

<section>
	<h2>Phylogenetic reconstruction</h2>
	
	<div align="left" style="margin-top:5%; margin-left:5%; width:85%">
	There are essentially two types of data for phylogenetic tree estimation:
	</div>

	<ul class="spaced" style="margin-top:5%; width:70%">

		<li><font color="red">Distance data</font>, usually stored in a distance matrix, e.g. DNAÃ—DNA hybridisation data, morphometric differences, immunological data, pairwise genetic distances</li>
		<li><font color="red">Character data</font>, usually stored in a character array, e.g. multiple sequence alignment of DNA sequences, morphological characters.</li>
	</ul>
</section>

<section>
	<h2>Phylogenetic reconstruction</h2>
	
	<div align="left" style="margin-top:5%; margin-left:5%; width:85%">
	There are a huge number of possible trees even for small data sets. 
	</div>
	<div align="left" style="margin-top:5%; margin-left:5%; width:85%">
	We have three options:
	</div>
	<ul class="spaced" style="margin-top:5%; width:70%">
		<li>Construct a tree according to some clustering algorithm</li>
		<li>Assign a goodness of fit criterion (an objective function) and find the tree(s) which optimise(s) this criterion</li>
		<li>Admit it is a statistical estimation problem and find the most probable phylogenies under a statistical model.</li>
	</ul>
</section>

<section>
	<h2>Phylogenetic reconstruction</h2>
</section>

<section>
	<h2> Clustering algorithms</h2>
	
	<div align="left" style="margin-top:5%; margin-left:5%; width:85%">
	Common clustering algorithms are <font color="red">Neighbour-joining</font> and <font color="red">UPGMA</font> (Unweighted Pair-Group Method using Arithmetic averages).
The clustering algorithms are usually very fast, and simple but there is no explicit optimality criterion, so
	</div>

	<ul class="spaced" style="margin-top:5%; width:70%">
		<li>the method provides no measure of how good the tree is!</li>
		<li>we do not get any idea about other potential trees - were there any better trees?</li>
	</ul>
</section>

<section>
	<h2> Clustering algorithms</h2>
	<ul class="spaced" style="margin-top:5%; width:70%">
		<li>The UPGMA and neighbor-joining (NJ) methods are both
greedy heuristics which join, at each step, the two closest*
sub-trees that are not already joined.</li>
		<li>They are based on the minimum evolution principle.</li>
		<li>An important concept in both of these methods is a pair of
neighbors, which is defined as two nodes that are connected
via a single node:</li>
	</ul>
</section>



